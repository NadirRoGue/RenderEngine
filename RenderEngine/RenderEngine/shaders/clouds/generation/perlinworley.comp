#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image3D outVolTex;

float seed1;
float seed2;
float seed3;


// =====================================================================================
// COMMON
float random2D( in vec2 st ) 
{
    return fract( sin(dot( st.xy, vec2(seed1,seed2 ) ) ) * seed3);
}

// =====================================================================================
// WORLEY NOISE SPECIFIC

uniform float worleyscale = 8.0;
uniform int worleyOctaves = 3;
uniform float worleyAmplitude = 1.0;
uniform float worleyFrecuency = 1.0;

float worleyNoise(vec2 uv, float freq, bool mod)
{
	vec2 offset = vec2( -1.0, -1.0 );

	float wa = worleyAmplitude;
	float wf = freq;
    
    float total = 0.0;
    
    for(int i = 0; i < worleyOctaves; i++)
    {
        vec2 currentPos = uv * worleyscale * wf; 
    	vec2 gridCoord  = floor( currentPos );
        float dist0 = 1000.0;
        
        for( offset.y = -1.0f; offset.y <= 1.0f; offset.y += 1.0f )
        {
            for( offset.x = -1.0f; offset.x <= 1.0f; offset.x += 1.0f )
            {
                vec2 cellCenter = gridCoord + offset;
                cellCenter      = cellCenter + random2D( cellCenter );

                float dist = length( cellCenter - currentPos );

                if( dist < dist0 )
                {
                    dist0 = dist;
                }
            }
        }
        
        total += (0.7 - dist0 * dist0) * wa;
        wa *= 0.25;
        wf *= 3.0; 
    }
   
   total = mod? total + clamp((0.6 - total) * 0.4, 0.0, 0.5) : total;
   return total;
}

// =====================================================================================
// PERLIN NOISE SPECIFIC

uniform float perlinAmplitude = 0.5;
uniform float perlinFrecuency = 0.5;
uniform float perlinScale = 12.0;
uniform int perlinOctaves = 8;

float noiseInterpolation(in vec2 i_coord, in float i_size)
{
	vec2 grid = i_coord * i_size;
    
    vec2 randomInput = floor( grid );
    vec2 weights     = fract( grid );
    
    
    float p0 = random2D( randomInput );
    float p1 = random2D( randomInput + vec2( 1.0, 0.0  ) );
    float p2 = random2D( randomInput + vec2( 0.0, 1.0 ) );
    float p3 = random2D( randomInput + vec2( 1.0, 1.0 ) );
    
    weights = smoothstep( vec2( 0.0, 0.0 ), vec2( 1.0, 1.0 ), weights ); 
    
    return p0 +
           ( p1 - p0 ) * ( weights.x ) +
           ( p2 - p0 ) * ( weights.y ) * ( 1.0 - weights.x ) +
           ( p3 - p1 ) * ( weights.y * weights.x );    
}

float perlinNoise(vec2 uv)
{
    float noiseValue = 0.0;
    
    float localAplitude  = perlinAmplitude;
    float localFrecuency = perlinFrecuency;

    for( int index = 0; index < perlinOctaves; index++ )
    {
     	       
        noiseValue += noiseInterpolation( uv, perlinScale * localFrecuency ) * localAplitude;
    
        localAplitude   *= 0.3333;
        localFrecuency  *= 3.0;
    }    

	// Switch to range -1 to 1
	noiseValue = (noiseValue * 2.0 - 1.0);
    // Apply "puffiness"
    noiseValue = abs(noiseValue * 2.0 + 1.0);

	return noiseValue;
}

// =====================================================================================
// PERLING-WORLEY FBM

float perlinWorleyFBM(vec2 uv)
{
	float perlin = perlinNoise(uv);
	float worley = worleyNoise(uv, worleyFrecuency, false);

	float result = 0.5 + (((worley - perlin) / (2.5 - worley)) * (0.5));
    
    result *= 1.1;

	return clamp(result, 0.0, 1.0);
}

// =====================================================================================


void main()
{
    ivec3 pixel = ivec3(gl_GlobalInvocationID.xyz);
	
	seed1 = 12.9898;// * float(pixel.z + 1);
	seed2 = 78.233;// + float(pixel.z) * 5.0;
	seed3 = 43758.5453123;// + pixel.z * (seed2 - seed1);

	vec2 uv = vec2(float(pixel.x) / 128.0, float(pixel.y) / 128.0);

	float pwFBM = perlinWorleyFBM(uv);
	float w1 = clamp(worleyNoise(uv, worleyFrecuency, true), 0.0, 1.0);
	float w2 = clamp(worleyNoise(uv, worleyFrecuency + 0.7, true), 0.0, 1.0);
	float w3 = clamp(worleyNoise(uv, worleyFrecuency + 1.4, true), 0.0, 1.0);

	vec4 volumeData = vec4(pwFBM, w1, w2, w3);
	//vec4 volumeData = vec4(1,0,0,1);

	imageStore (outVolTex, pixel, volumeData);
}
